import { Observable } from 'rxjs';
import type { InquirerReadline } from '@inquirer/type';
import type { Answers, Question, QuestionAnswerMap, QuestionArray, QuestionObservable, StreamOptions } from '../types.mjs';
export declare const _: {
    set: (obj: Record<string, unknown>, path: string | undefined, value: unknown) => void;
    get: (obj: object, path?: string | number | symbol, defaultValue?: unknown) => any;
};
export interface PromptBase {
    /**
     * Runs the prompt.
     *
     * @returns
     * The result of the prompt.
     */
    run(): Promise<any>;
}
/**
 * Provides the functionality to initialize new prompts.
 */
export interface LegacyPromptConstructor {
    /**
     * Initializes a new instance of a prompt.
     *
     * @param question
     * The question to prompt.
     *
     * @param readLine
     * An object for reading from the command-line.
     *
     * @param answers
     * The answers provided by the user.
     */
    new (question: any, readLine: InquirerReadline, answers: Record<string, any>): PromptBase;
}
export type PromptFn<Value = any, Config = any> = (config: Config, context?: StreamOptions) => Promise<Value>;
/**
 * Provides a set of prompt-constructors.
 */
export type PromptCollection = Record<string, PromptFn | LegacyPromptConstructor>;
/**
 * Base interface class other can inherits from
 */
export default class PromptsRunner<A extends Answers> {
    prompts: PromptCollection;
    answers: Partial<A>;
    process: Observable<any>;
    onClose?: () => void;
    opt?: StreamOptions;
    rl?: InquirerReadline;
    constructor(prompts: PromptCollection, opt?: StreamOptions);
    run(questions: QuestionArray<A> | QuestionAnswerMap<A> | QuestionObservable<A> | Question<A>, answers?: Partial<A>): Promise<A> & {
        ui: PromptsRunner<A>;
    };
    /**
     * Once all prompt are over
     */
    onCompletion(): Partial<A>;
    onError(error: Error): Promise<never>;
    processQuestion(question: Question<A>): Observable<{
        name: import("@inquirer/type").KeyUnion<A>;
        answer: unknown;
    }>;
    fetchAnswer(question: Question<A>): Observable<{
        name: import("@inquirer/type").KeyUnion<A>;
        answer: unknown;
    }>;
    /**
     * Handle the ^C exit
     */
    onForceClose: () => void;
    /**
     * Close the interface and cleanup listeners
     */
    close: () => void;
    setDefaultType: (question: Question<A>) => Observable<Question<A>>;
    filterIfRunnable: (question: Question<A>) => Observable<Question<A>>;
}
